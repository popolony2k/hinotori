(*<opl4.pas>
 * Library for OPL4 (YMF278B) soundchip handling.
 * CopyLeft (c) 1995-2024 by PopolonY2k.
 * CopyLeft (c) since 2024 by Hinotori Team.
 *)

(*
 * This module depends on folowing include files (respect the order):
 * - /sndchips/sndchips.pas;
 *)

Const
       { OPL4 related constants }
       ctPortYMF278BFMReg1        : Byte = $C4;   { YMF278B FM register 1 }
       ctPortYMF278BFMData1       : Byte = $C5;   { YMF278B FM data 1 }
       ctPortYMF278BFMReg2        : Byte = $C6;   { YMF278B FM register 2 }
       ctPortYMF278BFMData2       : Byte = $C7;   { YMF278B FM data 2 }
       ctPortYMF278BWaveReg       : Byte = $7E;   { YMF278B Wave register }
       ctPortYMF278BWaveData      : Byte = $7F;   { YMF278B Wave data }
       (*ctPortYMF278BStatus        : Byte = $C4;   { YMF278B Status }*)
       ctYMF278BWaveChannels      : Byte = $18;   { YMF278B Wave channels }
       ctYMF278BFMReg1Index       : Byte = $00;   { YMF278B FM Reg. 1 index }
       ctYMF278BFMReg2Index       : Byte = $01;   { YMF278B FM Reg. 2 index }
       ctYMF278BWaveRegIndex      : Byte = $02;   { YMF278B WAV Reg. index }

(**
  * Write data to OPL4 sound chip using internal variable parameter;
  * @param __pSndChipArrayParms The address of an array containing the OPL4
  * data like below:
  * item[0] := OPL4 Register output port index;
  * item[1] := OPL4 Register;
  * item[2] := OPL4 Data;
  *)
Procedure WriteOPL4Direct{( __pSndChipArrayParms : Pointer )};
Begin
  (*
   * The ASM routine below is located in the .\ASM\ project folder
   * and was generated by INLASS.
   *)
  Inline(
          $2A/__pSndChipArrayParms {        LD HL,(__pSndChipArrayParms) }
          /$7E                     {        LD A,(HL)                    }
          /$FE/$02                 {        CP OPL4_WAV                  }
          /$28/$19                 {        JR Z,WRTWAVE                 }
                                   { MACRO  WRT_OPL4 1,OPL4FMR2          }
          /$23                     {        INC HL                       }
          /$7E                     {        LD A,(HL)                    }
          /$0E/$C6                 {        LD C,OPL4FMR2                }
          /$ED/$79                 {        OUT (C),A                    }
          /$DB/$C4                 { WAITA1 IN A,(OPL4STS)               }
          /$E6/$01                 {        AND OPL4_BSY                 }
          /$20/$FA                 {        JR NZ,WAITA1                 }
                                   { MACRO  WRT_OPL4 2,OPL4FMD2          }
          /$23                     {        INC HL                       }
          /$7E                     {        LD A,(HL)                    }
          /$0E/$C7                 {        LD C,OPL4FMD2                }
          /$ED/$79                 {        OUT (C),A                    }
          /$DB/$C4                 { WAITB2 IN A,(OPL4STS)               }
          /$E6/$01                 {        AND OPL4_BSY                 }
          /$20/$FA                 {        JR NZ,WAITB2                 }
          /$C9                     {        RET                          }
                                   { MACRO  WRTWAVE WRT_OPL4 3,OPL4WAVR  }
          /$23                     {        INC HL                       }
          /$7E                     {        LD A,(HL)                    }
          /$0E/$7E                 {        LD C,OPL4WAVR                }
          /$ED/$79                 {        OUT (C),A                    }
          /$DB/$C4                 { WAITC3 IN A,(OPL4STS)               }
          /$E6/$01                 {        AND OPL4_BSY                 }
          /$20/$FA                 {        JR NZ,WAITC3                 }
                                   { MACRO  WRT_OPL4 4,OPL4WAVD          }
          /$23                     {        INC HL                       }
          /$7E                     {        LD A,(HL)                    }
          /$0E/$7F                 {        LD C,OPL4WAVD                }
          /$ED/$79                 {        OUT (C),A                    }
          /$DB/$C4                 { WAITD4 IN A,(OPL4STS)               }
          /$E6/$01                 {        AND OPL4_BSY                 }
          /$20/$FA                 {        JR NZ,WAITD4                 }
                                   {        END                          } );
End;

(**
  * Write data to OPL4 sound chip port. This is a wrapper to the
  * @see WriteOPL4FMDirect;
  * @param nPortIndex The port index that register data will be sent;
  * @param nRegister The register index to write data;
  * @param nData The data to be written;
  *)
Procedure WriteOPL4( nPortIndex, nRegister, nData : Byte );
Var
       aOPL4ArrayParms : Array [0..2] Of Byte;

Begin
  aOPL4ArrayParms[0] := nPortIndex;
  aOPL4ArrayParms[1] := nRegister;
  aOPL4ArrayParms[2] := nData;

  __pSndChipArrayParms := Ptr( Addr( aOPL4ArrayParms ) );

  WriteOPL4Direct{( __pSndChipArrayParms )};
End;

(**
  * Reset the OPL4 soundchip.
  * This routine below was suggested by ToriHino based on his RoboPlay
  * VGM Player written in C.
  * The original C code can be reached at RoboPlay repository at:
  * http://gitlab.com/torihino/roboplay/-/blob/master/opl4.c
  *)
Procedure ResetOPL4;
Var
       nValue,
       nCount : Byte;

Begin
  { Set to OPL4 mode }
  WriteOPL4( ctYMF278BFMReg2Index, $05, $03 );

  { Reset FM registers }
  WriteOPL4( ctYMF278BFMReg1Index, $01, $00 );
  WriteOPL4( ctYMF278BFMReg1Index, $02, $00 );
  WriteOPL4( ctYMF278BFMReg1Index, $03, $00 );
  WriteOPL4( ctYMF278BFMReg1Index, $04, $00 );
  WriteOPL4( ctYMF278BFMReg1Index, $08, $00 );

  WriteOPL4( ctYMF278BFMReg2Index, $01, $00 );
  WriteOPL4( ctYMF278BFMReg2Index, $02, $00 );
  WriteOPL4( ctYMF278BFMReg2Index, $03, $00 );
  WriteOPL4( ctYMF278BFMReg2Index, $04, $00 );
  WriteOPL4( ctYMF278BFMReg2Index, $08, $00 );

  For nCount := $14 to $F5 Do
  Begin
    If( ( nCount >= $60 ) And ( nCount < $A0 ) )  Then
      nValue := $FF
    Else
      nValue := $00;

   WriteOPL4( ctYMF278BFMReg1Index, nCount, nValue );
   WriteOPL4( ctYMF278BFMReg2Index, nCount, nValue );
  End;

  { Set mix control }
  WriteOPL4( ctYMF278BWaveRegIndex, $F8, $1B );
  WriteOPL4( ctYMF278BWaveRegIndex, $F9, $00 );

  { Reset WAVE registers }
  For nCount := 0 To ( ctYMF278BWaveChannels - 1 ) Do
    WriteOPL4( ctYMF278BWaveRegIndex, ( $68 + nCount ), $40 );

  { Reset timer flags }
  WriteOPL4( ctYMF278BFMReg1Index, $04, $80 );
End;
