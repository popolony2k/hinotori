(*<maprallc.pas>
 * Memory mapper management implementation using MSXDOS2 EXTBIO calls.
 * CopyLeft (c) 1995-2024 by PopolonY2k.
 * CopyLeft (c) since 2024 by Hinotori Team.
 *)

(*
 * This module depends on folowing include files (respect the order):
 * - /system/types.pas;
 * - /bios/msxbios.pas;
 * - /bios/extbio.pas;
 * - /mapper/maprdefs.pas;
 * - /mapper/maprbase.pas;
 *)

(**
  * Mapper allocation model.
  *)
Type TAllocMode = ( UseSpecifiedSlotOnly,
                    UseAnotherSlotThanSpecified,
                    UseAnotherSlotIfFailCurrentSlot,
                    UseCurrentSlotIfFailAnotherSlot );


(**
  * Allocate a memory mapper segment.
  * @param handle The allocated handle by the @see InitMapper routine;
  * @param mode Allocation mode. The SlotId parameter should be changed
  * depending on mode passed as parameter;
  * @param nSlotId The mapper slot id that segment will be allocated.
  * Depending on mode parameter, the SlotId returned can be different of
  * passed as parameter as described below:
  *  - UseSpecifiedSlotOnly The routine will alloc a segment only on mapper
  *    present on slot passed as parameter;
  *  - UseAnotherSlotThanSpecified Try to allocate a segment on a slot
  *    different of specified as parameter SlotId;
  *  - UseAnotherSlotIdFailCurrentSlot Allocate on another mapper slot only
  *    if was not possible to allocate on specified SlotId;
  *  - UseCurrentSlotIfFailAnotherSlot Allocate on current SlotId only if
  *    was not possible to allocate on another SlotId;
  * If nSlotId parameter is zero, the segment will be allocated on primary
  * mapper;
  * @param segmentType The @see TSegmentType that will be allocated by this
  * function;
  * @param nSegmentId The allocated segment id if the allocation was
  * successfull;
  *)
Function AllocMapperSegment( Var handle     : TMapperHandle;
                             mode           : TAllocMode;
                             Var nSlotId    : TSlotNumber;
                             segmentType    : TSegmentType;
                             Var nSegmentId : Byte ) : Boolean;

Const    { Slot Id masks }
         __ctUseSpecifiedSlotOnly        = $00; { Alloc specified slot only   }
         __ctUseAnotherSlotThanSpecified = $10; { Alloc other than specified  }
         __ctUseAnotherSlotIfFailCurrent = $20; { Alloc other if fail current }
         __ctUseCurrentSlotIfFailAnother = $30; { Alloc current if fail other }

Var
        nRetCode      : Byte;
        nSegType      : Byte;
        nSegId        : Byte;
        nJmpTblAddr   : Integer;
        nMaskedSlotId : TSlotNumber;

Begin
  If( segmentType = UserSegment )  Then
    nSegType := 0
  Else
    nSegType := 1;

  Case mode Of
    UseSpecifiedSlotOnly :
      nMaskedSlotId := ( nSlotId Or __ctUseSpecifiedSlotOnly );
    UseAnotherSlotThanSpecified :
      nMaskedSlotId := ( nSlotId Or __ctUseAnotherSlotThanSpecified );
    UseAnotherSlotIfFailCurrentSlot :
      nMaskedSlotId := ( nSlotId Or __ctUseAnotherSlotIfFailCurrent );
    UseCurrentSlotIfFailAnotherSlot :
      nMaskedSlotId := ( nSlotId Or __ctUseCurrentSlotIfFailAnother );
  End;

  nJmpTblAddr := handle.nStartAddrJumpTbl + ctALL_SEG;

  (*
   * The ASM routine below is located in the .\ASM\ project folder
   * and was generated by INLASS.
   *)
  Inline(
          $21/*+$000E          {       LD HL,retj                   }
          /$E5                 {       PUSH HL                      }
          /$3A/nMaskedSlotId   {       LD A,(nMaskedSlotId)         }
          /$47                 {       LD B,A                       }
          /$3A/nSegType        {       LD A,(nSegType)              }
          /$2A/nJmpTblAddr     {       LD HL,(nJmpTblAddr)          }
          /$E9                 {       JP (HL)                      }
          /$32/nSegId          { retj: LD (nSegId),A                }
          /$78                 {       LD A,B                       }
          /$32/nMaskedSlotId   {       LD (nMaskedSlotId),A         }
          /$26/$00             {       LD H,0                       }
          /$38/$02             {       JR C,endf                    }
          /$26/$01             {       LD H,1                       }
          /$7C                 { endf: LD A,H                       }
          /$32/nRetCode        {       LD (nRetCode),A              }
                               {       END                          } );

  nSlotId    := nMaskedSlotId;
  nSegmentId := nSegId;
  AllocMapperSegment := Boolean( nRetCode );
End;

(**
  * Release an allocated memory mapper segment.
  * @param handle The allocated handle by the @see InitMapper routine;
  * @param nSlotId The mapper id that will be deallocated;
  * @param nSegmentId The mapper id that will be deallocated;
  *)
Function FreeMapperSegment( Var handle : TMapperHandle;
                            nSlotId    : TSlotNumber;
                            nSegmentId : Byte ) : Boolean;
Var
        nRetCode     : Byte;
        nJmpTblAddr  : Integer;

Begin
  nJmpTblAddr := handle.nStartAddrJumpTbl + ctFRE_SEG;

  (*
   * The ASM routine below is located in the .\ASM\ project folder
   * and was generated by INLASS.
   *)
  Inline(
          $21/*+$000E          {       LD HL,retj                   }
          /$E5                 {       PUSH HL                      }
          /$3A/nSlotId         {       LD A,(nSlotId)               }
          /$47                 {       LD B,A                       }
          /$3A/nSegmentId      {       LD A,(nSegmentId)            }
          /$2A/nJmpTblAddr     {       LD HL,(nJmpTblAddr)          }
          /$E9                 {       JP (HL)                      }
          /$26/$00             { retj: LD H,0                       }
          /$38/$02             {       JR C,endf                    }
          /$26/$01             {       LD H,1                       }
          /$7C                 { endf: LD A,H                       }
          /$32/nRetCode        {       LD (nRetCode),A              }
                               {       END                          } );

  FreeMapperSegment := Boolean( nRetCode );
End;
